'use strict'

const REST_API_ID_KEY = 'ApiGatewayRestApiWaf';
const DEFAULT_WAF_VERSION = "WAFRegional"
const DEFAULT_WAF_SCOPE = "REGIONAL"

const get = (obj, path, defaultValue) => {
  return path.split('.').filter(Boolean).every(step => !(step && !(obj = obj[step]))) ? obj : defaultValue
}

class AssociateWafPlugin {
  constructor(serverless, options, utils) {
    this.serverless = serverless
    this.provider = this.serverless.providers.aws
    // serverless v3 logging with a fallback to v1/v2
    this.log = utils?.log || { info: serverless.cli.log, warning: serverless.cli.log, error: serverless.cli.log };

    this.config = get(this.serverless.service, 'custom.associateWaf', {})

    this.wafVersion = `WAF${this.config.version || "Regional"}` //config.version can be one of [V2, Regional]
    this.wafScope = DEFAULT_WAF_SCOPE //WAFV2 requires a scope setting
    this.verifyValidWafConfig()
    this.hooks = {}

    this.hooks['after:deploy:deploy'] = this.updateWafAssociation.bind(this)
    this.hooks['before:package:finalize'] = this.updateCloudFormationTemplate.bind(this)
  }

  verifyValidWafConfig() {
    const validVersions = [DEFAULT_WAF_VERSION, "WAFV2"] //allowed WAF versions
    if (!validVersions.includes(this.wafVersion)) {
      this.wafVersion = DEFAULT_WAF_VERSION
      this.log.warning(`\n-------- Invalid WAF Version Configuration --------\nVersion Defaulted to ${this.wafVersion}`)
    }
  }

  defaultStackName() {
    return `${this.serverless.service.getServiceName()}-${this.provider.getStage()}`
  }

  getApiGatewayStageArn(restApiId) {
    return `arn:${this.getPartition()}:apigateway:${this.provider.getRegion()}::/restapis/${restApiId}/stages/${this.provider.getStage()}`
  }

  // Ideally serverless adds this to the provider in the future, see https://github.com/serverless/serverless/issues/12441
  // Could get from account info, but that'd require an async fetch, see https://github.com/mikesouza/serverless-associate-waf/pull/56/changes/32d32dd749a0ae3ae16afbef39c8fb00dccfa04a
  getPartition() {
    const region = this.provider.getRegion();
    if (region.startsWith('cn-')) {
      return 'aws-cn';
    }
    if (region.startsWith('us-gov-')) {
      return 'aws-us-gov';
    }
    return 'aws';
  }

  updateCloudFormationTemplate() {
    this.outputRestApiId()
  }

  outputRestApiId() {
    const autoGeneratedRestApiId = { Ref: 'ApiGatewayRestApi' };

    this.serverless.service.provider.compiledCloudFormationTemplate.Outputs[REST_API_ID_KEY] = {
      Description: 'Rest API Id',
      Value: autoGeneratedRestApiId,
    };
  };

  async updateWafAssociation() {
    if ((this.config) && (this.config.name) && (this.config.name.trim().length != 0)){
      await this.associateWaf();
    } else {
      await this.disassociateWaf();
    }
  }

  async findWebAclByName(name) {
    let params = { Limit: 100 }
    if (this.wafVersion !== DEFAULT_WAF_VERSION) { //WAFV2 requires Scope variable
      params.Scope = this.wafScope
    }

    const response = await this.provider.request(this.wafVersion, 'listWebACLs', params)
    if (response.WebACLs) {
      for (let webAcl of response.WebACLs) {
        if (name === webAcl.Name) {
          return this.wafVersion === DEFAULT_WAF_VERSION ? webAcl.WebACLId : webAcl.ARN //WAFV2 uses WebACLArn instead of WebACLId
        }
      }
    }
  }

  async findStackResourceByLogicalId(stackName, logicalId) {
    const response = await this.provider.request('CloudFormation', 'listStackResources', { StackName: stackName })
    if (response.StackResourceSummaries) {
      for (let resourceSummary of response.StackResourceSummaries) {
        if (logicalId === resourceSummary.LogicalResourceId) {
          return resourceSummary
        }
      }
    }
  }

  async findStackOutputByLogicalId(stackName, logicalId) {
    const response = await this.provider.request('CloudFormation', 'describeStacks', { StackName: stackName })
    if(response.Stacks) {
      if (response.Stacks[0].Outputs) {
        for (let resourceSummary of response.Stacks[0].Outputs) {
          if (logicalId === resourceSummary.OutputKey) {
            return resourceSummary
          }
        }
      }
    }
  }

  async getRestApiId() {
    const apiGateway = this.serverless.service.provider.apiGateway
    if (apiGateway && apiGateway.restApiId) {
      return apiGateway.restApiId
    }

    const stackName = this.serverless.service.provider.stackName || this.defaultStackName();

    const stackResource = await this.findStackResourceByLogicalId(stackName, 'ApiGatewayRestApi')
    if (!stackResource) {
      this.log.info(`RestApiId not found (split stacks plugin used?), using stack outputs for RestApiId.`);
      const stackOutput = await this.findStackOutputByLogicalId(stackName, REST_API_ID_KEY)
      if (stackOutput && stackOutput.OutputValue) {
        return stackOutput.OutputValue
      }
    }

    if (stackResource && stackResource.PhysicalResourceId) {
      return stackResource.PhysicalResourceId
    }
  }

  async associateWaf() {
    try {
      const restApiId = await this.getRestApiId()
      if (!restApiId) {
        this.log.warning('Unable to determine REST API ID')
        return
      }

      const webAclId = await this.findWebAclByName(this.config.name)
      if (!webAclId) {
        this.log.warning(`Unable to find WAF named '${this.config.name}'`)
        return
      }

      const params = this.wafVersion === DEFAULT_WAF_VERSION ?
        {
          ResourceArn: this.getApiGatewayStageArn(restApiId), //used for WAFRegional
          WebACLId: webAclId
        }
        :
        {
          ResourceArn: this.getApiGatewayStageArn(restApiId), //used for WAFV2
          WebACLArn: webAclId
        }

      this.log.info('Associating WAF...')
      await this.provider.request(this.wafVersion, 'associateWebACL', params)
    } catch (e) {
      this.log.error(`\n-------- Associate WAF Error --------\n${e.message}`)
    }
  }

  async disassociateWaf() {
    try {
      const restApiId = await this.getRestApiId()
      if (!restApiId) {
        this.log.warning('Unable to determine REST API ID')
        return
      }

      const params = {
        ResourceArn: this.getApiGatewayStageArn(restApiId)
      }

      const webACLForResource = await this.provider.request(this.wafVersion, 'getWebACLForResource', params)
      if (webACLForResource.WebACLSummary || webACLForResource.WebACL) { //WAFV2 uses WebACL
        this.log.info('Disassociating WAF...')
        await this.provider.request(this.wafVersion, 'disassociateWebACL', params)
      }

    } catch (e) {
      this.log.error(`\n-------- Disassociate WAF Error --------\n${e.message}`)
    }
  }
}

module.exports = AssociateWafPlugin
